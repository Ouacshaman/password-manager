// Argon2 package is used to generate a master key

use argon2::{Argon2, password_hash::SaltString};

use argon2::password_hash::rand_core::OsRng;

use clap::Parser;
use dotenvy::dotenv;
use sqlx;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long, value_name = "master_password")]
    master_pw: Option<String>,
}

#[tokio::main]

async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    dotenv().ok();

    let conn_str =
        std::env::var("DATABASE_URL").expect("Database Url is not entered into dotenv file");

    println!("{}", conn_str);

    let _pool = sqlx::SqlitePool::connect(&conn_str).await?;

    let mpw = cli
        .master_pw
        .unwrap_or_else(|| "No String Found".to_string());
    let b_pw: &[u8] = mpw.as_bytes();
    let mut output_key_material = [0u8; 32];

    let salt = SaltString::generate(&mut OsRng);

    let mut salt_buf = [0u8; 32];

    let raw_salt = salt.decode_b64(&mut salt_buf).unwrap();

    let _ = Argon2::default()
        .hash_password_into(b_pw, raw_salt, &mut output_key_material)
        .expect("failed hash");

    Ok(())
}

#[derive(sqlx::FromRow, Debug)]
pub struct Vault {
    pub id: i32,
    pub kdf_salt: Vec<u8>,
    pub kdf_params: String,
    pub nonce: Vec<u8>,
    pub sealed_data_key: Vec<u8>,
    pub verifier: Option<Vec<u8>>,
    pub created_at: Option<String>,
}

async fn get_vault(p: &sqlx::SqlitePool) -> Result<Vault, Box<dyn std::error::Error>> {
    let vault = sqlx::query_as::<_, Vault>(
        r#"
        SELECT
            id,
            kdf_salt,
            kdf_params,
            nonce,
            sealed_data_key,
            verifier,
            created_at
        FROM vault_meta
        WHERE id = 1
        "#,
    )
    .fetch_all(p)
    .await?;

    println!("{vault:#?}")

    Ok(vault)
}
